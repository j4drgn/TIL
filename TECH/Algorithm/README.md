# 알고리즘 학습

이 디렉토리는 알고리즘 학습과 관련된 코드와 개념을 정리한 공간입니다.

## 디렉토리 구조

### a_ot
- 기본 알고리즘 개념 및 연산자 활용 예제
- XOR 연산을 활용한 변수 교환 등의 기법

### b_star
- 별 찍기 패턴 알고리즘
- 다이아몬드, 나비 등 다양한 패턴 구현

### c_math
- 수학 관련 알고리즘
- 소수 판별, 최대공약수(GCD), 최소공배수(LCM), 팩토리얼 등

### d_datastructure
- 자료구조 구현
- ArrayList, LinkedList, HashSet 등 기본 자료구조의 직접 구현
- dto, list, set, map, queue, stack, bst 패키지로 구성

### e_search
- 검색 알고리즘 구현
- 선형 탐색(Linear Search)
- 이진 탐색(Binary Search)

### f_bruteforce
- 정렬 알고리즘 구현
- 버블 정렬(Bubble Sort)
- 선택 정렬(Selection Sort)

### f2_lambda
- 람다 표현식과 함수형 인터페이스 구현
- Consumer, Supplier, Function, Predicate 인터페이스

### g_divideandconcure
- 분할 정복 알고리즘 구현
- 병합 정렬(Merge Sort): 하향식(Top-down)과 상향식(Bottom-up) 구현
- 퀵 정렬(Quick Sort): 재귀적 구현과 비재귀적(스택 기반) 구현
- 거듭제곱 계산: 분할 정복을 이용한 O(log n) 알고리즘

### h_dp
- 동적 계획법(Dynamic Programming) 알고리즘 구현
- 피보나치 수열: 재귀적 접근법과 동적 계획법 비교

### util
- 알고리즘 구현에 필요한 유틸리티 클래스
- SortUtil: 정렬 알고리즘 유틸리티
- Timer: 알고리즘 실행 시간 측정 인터페이스

## 주요 학습 내용

### 1. XOR 연산을 활용한 변수 교환

임시 변수 없이 두 변수의 값을 교환하는 방법을 구현했습니다.

```java
a = a ^ b;  // a = 1011 ^ 10000 = 11011
b = a ^ b;  // b = 11011 ^ 10000 = 1011 (원래의 a 값)
a = b ^ a;  // a = 1011 ^ 11011 = 10000 (원래의 b 값)
```

XOR 연산의 주요 특성:
- a xor 0 = a (어떤 값이든 0과 XOR 연산하면 원래 값이 유지됨)
- a xor 1 = not a (비트별로 1과 XOR 연산하면 비트가 반전됨)
- (a ^ b) ^ b = a
- (a ^ b) ^ a = b

### 2. 별 찍기 패턴

중첩 반복문을 활용하여 다양한 패턴의 별 찍기 알고리즘을 구현했습니다.

#### 구현된 패턴:

- **다이아몬드 패턴**: 상단부(점점 커지는 삼각형)와 하단부(점점 작아지는 역삼각형)로 구성
- **나비 패턴**: 좌우 대칭 구조로, 중앙에 공백을 두고 별표를 배치

#### 패턴 구현 방법:

- 중첩 반복문을 사용하여 행과 열 단위로 패턴 생성
- 공백과 별표의 개수를 수학적으로 계산하여 출력

### 3. 수학 알고리즘

#### 소수 판별 알고리즘

- **기본 방식**: 2부터 (n-1)까지 모든 수로 나누어 보는 방법
- **최적화 방식**: 2부터 sqrt(n)까지만 검사하는 방법 (약수는 쌍으로 존재하며, 그 쌍 중 하나는 반드시 sqrt(n) 이하)

#### 최대공약수(GCD) 계산

- **기본 방식**: 작은 수부터 1까지 감소시키며 공약수 찾기
- **유클리드 호제법**: GCD(a, b) = GCD(b, a % b)

#### 최소공배수(LCM) 계산

- LCM(a, b) = (a * b) / GCD(a, b)

#### 팩토리얼 구현

- **일반 재귀**: n! = n * (n-1)!
- **꼬리 재귀**: 반환부에 연산이 없는 최적화된 재귀 방식

### 4. 자료구조

#### DTO(Data Transfer Object)

- **School 클래스**: 학교 정보를 표현하는 DTO 클래스
  - Comparable 인터페이스 구현으로 비교 기능 제공
  - equals와 hashCode 메소드 오버라이드

#### 리스트(List) 구현

- **_ArrayList 클래스**: 동적 배열 구현
  - 요소 추가/조회/삭제 기능 구현
  - 배열 크기 동적 조정
  - Iterator 구현으로 향상된 for문 지원
- **_LinkedList 클래스**: 연결 리스트 구현
- **Node 클래스**: 연결 리스트의 노드 구현

#### 집합(Set) 구현

- **_HashSet_P1 클래스**: 기본적인 해시 집합 구현
  - 해시 충돌 시 추가 거부 방식
- **_HashSet_P2 클래스**: 체이닝 방식으로 해시 충돌 처리
  - 연결 리스트를 사용한 체이닝
  - Iterator 구현으로 향상된 for문 지원

#### 맵(Map) 구현

- **_HashMap 클래스**: 해시맵 구현
  - 키-값 쌍 저장
  - 해시 충돌 처리
- **Entry 클래스**: 키-값 쌍을 저장하는 엔트리 구현

#### 큐(Queue) 구현

- **_Queue 클래스**: 큐 자료구조 구현
  - FIFO(First In First Out) 방식
  - enqueue, dequeue 연산 지원

#### 스택(Stack) 구현

- **_Stack 클래스**: 스택 자료구조 구현
  - LIFO(Last In First Out) 방식
  - push, pop 연산 지원

#### 이진 탐색 트리(BST) 구현

- **BinarySearchTree 클래스**: 이진 탐색 트리 구현
  - 삽입, 삭제, 탐색 연산
  - 전위, 중위, 후위 순회 및 BFS 구현
- **Node 클래스**: 트리의 노드 구현

### 5. 탐색 알고리즘

#### 선형 탐색(Linear Search)

- 배열의 처음부터 끝까지 순차적으로 탐색
- 보초법(Sentinel Search)을 이용한 최적화

#### 이진 탐색(Binary Search)

- 정렬된 배열에서만 사용 가능
- 중간값을 기준으로 탐색 범위를 절반씩 줄여나가는 방식
- O(log n) 시간 복잡도

### 6. 정렬 알고리즘

#### 버블 정렬(Bubble Sort)

- 인접한 두 원소를 비교하여 정렬
- 최적화된 버전: 교환이 발생하지 않으면 조기 종료

#### 선택 정렬(Selection Sort)

- 배열에서 최소값을 찾아 맨 앞으로 이동시키는 과정 반복
- O(n²) 시간 복잡도

### 7. 분할 정복 알고리즘

#### 병합 정렬(Merge Sort)

- **하향식(Top-down) 구현**: 배열을 재귀적으로 분할하고 병합
  - 전체 배열에서 시작하여 작은 부분으로 분할
  - 재귀적으로 분할된 배열을 정렬 후 병합
- **상향식(Bottom-up) 구현**: 작은 부분 배열부터 병합
  - 크기가 1인 부분 배열부터 시작
  - 인접한 부분 배열들을 병합하며 크기를 2배씩 늘려감
- 시간 복잡도: O(n log n)

#### 퀵 정렬(Quick Sort)

- **재귀적 구현**: 피벗을 기준으로 배열을 분할하고 재귀적으로 정렬
- **비재귀적 구현**: 스택을 사용하여 재귀 호출 대체
- 시간 복잡도: 평균 O(n log n), 최악 O(n²)

#### 거듭제곱 계산

- 분할 정복을 이용한 효율적인 거듭제곱 계산
- a^b를 O(log b) 시간 복잡도로 계산
- 핵심 아이디어: a^b = (a^(b/2))^2 (b가 짝수) 또는 a * (a^(b/2))^2 (b가 홀수)

### 8. 동적 계획법(Dynamic Programming)

#### 피보나치 수열 계산

- **재귀적 접근법**: F(n) = F(n-1) + F(n-2)
  - 중복 계산이 많아 비효율적
  - 시간 복잡도: O(2^n)
- **동적 계획법 접근**: 이전 계산 결과를 저장하여 재사용
  - 시간 복잡도: O(n)
  - 공간 복잡도: O(1) (최적화된 구현)

### 9. 람다 표현식과 함수형 인터페이스

- **Consumer<T>**: 값을 받아서 소비하고 반환값이 없는 인터페이스
- **Supplier<T>**: 값을 제공하는 인터페이스
- **Function<T, R>**: 값을 받아서 다른 값으로 변환하는 인터페이스
- **Predicate<T>**: 값을 받아서 boolean을 반환하는 인터페이스
- 메서드 참조를 통한 간결한 코드 작성

## 알고리즘 최적화 기법

- 소수 판별 시 sqrt(n)까지만 검사
- 유클리드 호제법을 사용한 GCD 계산
- 꼬리 재귀를 통한 팩토리얼 최적화
- 보초법을 이용한 선형 탐색 최적화
- 버블 정렬에서 교환이 없는 경우 조기 종료
- 분할 정복을 이용한 거듭제곱 최적화
- 동적 계획법을 이용한 피보나치 수열 최적화

## 자료구조 설계 원칙

- 동적 크기 조정
- 해시 충돌 처리 방법
- 반복자(Iterator) 패턴 구현
- 트리 순회 알고리즘 구현

## 참고 자료

- 자바 공식 문서: [Java Documentation](https://docs.oracle.com/en/java/)
- 알고리즘 시각화: [VisuAlgo](https://visualgo.net/)
- 알고리즘 문제 해결 전략 (구종만 저)
- Introduction to Algorithms (CLRS)