# 2025-08-25 (월) 학습 내용

## 알고리즘 - 분할 정복(Divide and Conquer)

분할 정복은 문제를 더 작은 부분 문제로 나누어 해결하는 알고리즘 패러다임입니다.

### 병합 정렬(Merge Sort)

#### 하향식(Top-down) 병합 정렬

```java
private static int[] mergeSort(int[] arr) {
    int n = arr.length;
    if(n <= 1) return arr;
    
    int mid = n/2;
    int[] arr1 = mergeSort(Arrays.copyOfRange(arr, 0, mid));
    int[] arr2 = mergeSort(Arrays.copyOfRange(arr, mid, n));
    return merge(arr1, arr2);
}
```

- 전체 배열에서 시작하여 작은 부분으로 분할
- 재귀적으로 분할된 배열을 정렬 후 병합
- 진행 방향: 전체 배열 → 분할 → 정복 → 병합

#### 상향식(Bottom-up) 병합 정렬

```java
private static void mergeSort(int[] arr) {
    int n = arr.length;
    
    // size : 부분 배열의 길이
    for (int size = 1; size < n; size *= 2) {
        // left : 첫 번째 부분 배열의 시작 인덱스
        for (int left = 0; left < n-1; left += 2 * size) {
            int mid = Math.min(left + size - 1, n-1);
            // right : 두 번째 부분 배열의 끝 인덱스
            int right = Math.min(left + 2 * size -1, n-1);
            merge(arr, left, mid, right);
        }
    }
}
```

- 가장 작은 부분 문제(길이가 1인 배열)부터 시작
- 점점 큰 부분 배열을 병합하며 전체 배열을 정렬
- 진행 방향: 부분 → 전체

### 퀵 정렬(Quick Sort)

#### 재귀적 퀵 정렬

```java
private static void quickSort(int[] arr, int left, int right) {
    if(left >= right) return;
    int pivot = partition(arr, left, right);
    quickSort(arr, left, pivot-1);
    quickSort(arr, pivot + 1, right);
}
```

- 피벗을 기준으로 배열을 분할
- 재귀적으로 좌측, 우측 부분 배열을 정렬

#### 비재귀적 퀵 정렬

```java
private static void quickSort(int[] arr, int left, int right) {
    if(left >= right) return;
    _Stack<Integer> stack = new _Stack<Integer>();
    
    stack.push(left);
    stack.push(right);
    
    while(!stack.isEmpty()) {
        right = stack.pop();
        left = stack.pop();
        
        int pivotIndex = partition(arr, left, right);
        
        if(pivotIndex -1 > left) {
            stack.push(left);
            stack.push(pivotIndex -1);
        }
        
        if(pivotIndex + 1 < right) {
            stack.push(pivotIndex + 1);
            stack.push(right);
        }
    }
}
```

- 스택을 사용하여 재귀 호출을 대체
- 메모리 사용량 감소, 스택 오버플로우 방지

### 거듭제곱 계산 - 분할 정복 접근법

```java
public static long power(long a, long b) {
    // 1. 종료 조건 (Base Case): 지수가 0이면 1을 반환한다.
    if (b == 0) {
        return 1;
    }

    // 2. 분할 및 정복 (Divide and Conquer): b/2에 대한 거듭제곱을 재귀적으로 계산한다.
    long temp = power(a, b / 2);

    // 3. 조합 (Combine): 계산된 하위 문제의 결과를 조합한다.
    long result = temp * temp;

    // 4. 지수 b가 홀수인 경우, 밑 a를 한 번 더 곱해준다.
    if (b % 2 != 0) {
        result *= a;
    }

    return result;
}
```

- 시간 복잡도: O(log b)
- 지수를 절반씩 나누어 계산하는 효율적인 방법

## 알고리즘 - 동적 계획법(Dynamic Programming)

동적 계획법은 복잡한 문제를 더 작은 하위 문제로 나누고, 하위 문제의 결과를 저장하여 중복 계산을 피하는 방법입니다.

### 피보나치 수열

#### 재귀적 접근법 (비효율적)

```java
private static int fiboRecursive(int n) {
    if(n == 0) return 0;
    if(n == 1 || n == 2) return 1;
    return fiboRecursive(n-1) + fiboRecursive(n-2);
}
```

- 중복 계산이 많아 비효율적
- 시간 복잡도: O(2^n)

#### 동적 계획법 접근 (효율적)

```java
private static int fibonacci(int n) {
    if(n < 1) return -1;
    int prev = 1, cur = 1;
    
    for (int i = 3; i <= n; i++) {
        int temp = cur;
        cur = prev + cur;
        prev = temp;
    }
    
    return cur;
}
```

- 이전 계산 결과를 저장하여 중복 계산 방지
- 시간 복잡도: O(n)
- 공간 복잡도: O(1)

## 디자인 패턴 - 캡슐화(Encapsulation)

캡슐화는 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 객체의 자율성을 보장하는 기법입니다.

### 속성 캡슐화 예제

```java
public class Coffee {
    
    private String name;
    private int price;
    private int stock;
    
    // 읽기, 수정 : getter/setter
    // 읽기     : getter
    // 접근 x   : x
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getPrice() {
        return price;
    }
    public void setPrice(int price) {
        this.price = price;
    }
    public int getStock() {
        return stock;
    }
    public void setStock(int stock) {
        this.stock = stock;
    }
}
```

- 속성을 private으로 선언하여 직접 접근을 제한
- getter/setter 메소드를 통해 제어된 접근 제공

### 메소드 캡슐화 예제

```java
public class Player {
    
    private String instrument;

    public Player(String instrument) {
        super();
        this.instrument = instrument;
    }
    
    public void play() {
        prepare();
        playing();
        stop();
        leave();
        curtainCall();
    }
    
    private void prepare() {
        System.out.println(instrument + " 연주를 준비합니다.");
    }
    
    private void playing() {
        System.out.println(instrument + " 연주를 시작합니다.");
    }
    
    private void stop() {
        System.out.println("연주를 중단합니다.");
    }
    
    private void leave() {
        System.out.println("공연장을 떠납니다.");
    }
    
    private void curtainCall(){
        System.out.println("커튼콜을 진행합니다.");
    }
}
```

- 객체의 자율성 보장
- 내부 구현 메소드는 private으로 감추고 public 인터페이스만 노출
- 클라이언트는 `play()` 메소드만 호출하면 됨

### 템플릿 메소드 패턴의 전조

Spring, Summer, Autumn 콘서트 클래스들이 동일한 구조를 가지고 있어 템플릿 메소드 패턴의 적용 가능성을 보여줍니다:

```java
public class SpringConcert {
    public void start() {
        System.out.println("Spring concert 시작합니다. ^^ ******");
        Player player = new Player("바이올린");
        player.play();
        System.out.println("=====================================");
    }
}
```

- 세 콘서트 클래스 모두 동일한 구조의 `start()` 메소드를 가짐
- 추후 상속과 추상화를 통해 템플릿 메소드 패턴으로 리팩토링 가능
