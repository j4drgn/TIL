# 2025-08-19 (화)

## 알고리즘 학습 내용 정리

오늘 알고리즘 폴더에서 학습한 내용을 정리합니다.

### 1. XOR 연산을 활용한 변수 교환 (a_ot)

XOR 연산자를 활용하면 임시 변수 없이 두 변수의 값을 교환할 수 있습니다.

```java
int a = 10;
int b = 15;

a = a ^ b;  // a에 a와 b의 XOR 결과 저장
b = a ^ b;  // b에 (a^b)와 b의 XOR 결과 저장 => 원래 a 값이 됨
a = a ^ b;  // a에 (a^b)와 (원래 a)의 XOR 결과 저장 => 원래 b 값이 됨
```

XOR 연산의 특성:
- a XOR 0 = a
- a XOR 1 = not a
- (a XOR b) XOR b = a
- (a XOR b) XOR a = b

### 2. 별 찍기 패턴 (b_star)

다양한 패턴으로 별을 출력하는 알고리즘을 학습했습니다.

#### 다이아몬드 패턴
```java
// 위쪽 삼각형
for (int i = 1; i <= input; i++) {
  // 공백 출력
  for (int j = 1; j <= input - i; j++) {
    System.out.print(" ");
  }
  // 별 출력
  for (int k = 1; k <= 2 * i - 1; k++) {
    System.out.print("*");
  }
  System.out.println();
}

// 아래쪽 삼각형
for (int i = input - 1; i >= 1; i--) {
  // 공백 출력
  for (int j = 1; j <= input - i; j++) {
    System.out.print(" ");
  }
  // 별 출력
  for (int k = 1; k <= 2 * i - 1; k++) {
    System.out.print("*");
  }
  System.out.println();
}
```

#### 나비 패턴
```java
// 윗부분 날개
for (int i = 1; i <= input; i++) {
  // 왼쪽 별
  for (int j = 1; j <= i; j++) {
    System.out.print("*");
  }
  // 가운데 공백
  for (int k = 1; k <= 2 * input - 2 * i; k++) {
    System.out.print(" ");
  }
  // 오른쪽 별
  for (int j = 1; j <= i; j++) {
    System.out.print("*");
  }
  System.out.println();
}

// 아랫부분 날개
for (int i = input - 1; i >= 1; i--) {
  // 왼쪽 별
  for (int j = 1; j <= i; j++) {
    System.out.print("*");
  }
  // 가운데 공백
  for (int k = 1; k <= 2 * input - 2 * i; k++) {
    System.out.print(" ");
  }
  // 오른쪽 별
  for (int j = 1; j <= i; j++) {
    System.out.print("*");
  }
  System.out.println();
}
```

### 3. 수학 알고리즘 (c_math)

#### 소수 판별
```java
// 기본 방식
private static boolean isPrime(int num) {
  if (num == 2) return true;
  if (num % 2 == 0) return false;
  
  for (int i = 3; i < num; i++) {
    if (num % i == 0) return false;
  }
  return true;
}

// 최적화 방식 (제곱근까지만 확인)
private static boolean isPrime2(int num) {
  if (num == 2) return true;
  if (num % 2 == 0) return false;
  
  for (int i = 3; i <= Math.sqrt(num); i++) {
    if (num % i == 0) return false;
  }
  return true;
}
```

#### 최대공약수 (GCD)
```java
// 반복문 방식
private static int getGcd(int a, int b) {
  int min = Math.min(a, b);
  
  for (int i = min; i > 0; i--) {
    if (a % i == 0 && b % i == 0) {
      return i;
    }
  }
  return 1;
}

// 유클리드 호제법
private static int getGcd2(int a, int b) {
  while (b > 0) {
    int temp = b;
    b = a % b;
    a = temp;
  }
  return a;
}
```

#### 최소공배수 (LCM)
```java
private static int getLcm(int a, int b) {
  int gcd = getGcd(a, b);
  return a * b / gcd;
}
```

#### 팩토리얼
```java
// 일반 재귀
private static int getFactorial(int i) {
  if (i < 0) {
    throw new IllegalArgumentException("음수 펙토리얼은 존재하지 않습니다.");
  } else if (i <= 1) {
    return 1;
  }
  return i * getFactorial(i - 1);
}

// 꼬리 재귀
private static int factorialTail(int i, int res) {
  if (i < 0) {
    throw new IllegalArgumentException("음수 팩토리얼은 존재하지 않습니다.");
  }
  if (i <= 1) {
    return res;
  }
  
  res = i * res;
  return factorialTail(--i, res);
}
```

### 4. 자료구조 (d_datastructure)

ArrayList 구현:
```java
public class _ArrayList<E> {
  private Object[] elementData;
  private int size;
  private int arraySize = 10;
  
  // 생성자
  public _ArrayList() {
    elementData = new Object[arraySize];
  }
  
  public _ArrayList(int initialCapacity) {
    this.arraySize = initialCapacity;
    elementData = new Object[arraySize];
  }
  
  // 요소 추가
  public boolean add(E e) {
    if (size < arraySize) {
      elementData[size] = e;
      size++;
      return true;
    }
    
    // 배열 크기 확장
    arraySize *= 2;
    elementData = Arrays.copyOf(elementData, arraySize);
    elementData[size] = e;
    size++;
    
    return true;
  }
  
  // 요소 조회
  @SuppressWarnings("unchecked")
  public E get(int index) {
    if (index < 0 || index >= size) {
      throw new IndexOutOfBoundsException("인덱스 범위를 벗어났습니다.");
    }
    return (E) elementData[index];
  }
  
  // 요소 삭제
  @SuppressWarnings("unchecked")
  public E remove(int index) {
    if (index < 0 || index >= size) {
      throw new IndexOutOfBoundsException("인덱스 범위를 벗어났습니다.");
    }
    E prevElement = (E) elementData[index];
    
    // 삭제 후 요소 이동
    for (int i = index; i < size - 1; i++) {
      elementData[i] = elementData[i + 1];
    }
    
    elementData[size - 1] = null;
    size--;
    
    return prevElement;
  }
}
```

주요 구현 내용:
- 제네릭을 사용한 타입 안정성
- 동적 배열 크기 조정
- 요소 추가, 조회, 삭제 기능
- 인덱스 범위 검사를 통한 예외 처리
