# 2025-08-19 (화)

## 알고리즘 학습 내용 정리

오늘 알고리즘 폴더에서 학습한 내용을 정리합니다.

### 1. XOR 연산을 활용한 변수 교환 (a_ot)

XOR 연산자를 활용하면 임시 변수 없이 두 변수의 값을 교환할 수 있습니다.

```java
int a = 10;
int b = 15;

a = a ^ b;  // a에 a와 b의 XOR 결과 저장
b = a ^ b;  // b에 (a^b)와 b의 XOR 결과 저장 => 원래 a 값이 됨
a = a ^ b;  // a에 (a^b)와 (원래 a)의 XOR 결과 저장 => 원래 b 값이 됨
```

XOR 연산의 특성:

- a XOR 0 = a
- a XOR 1 = not a
- (a XOR b) XOR b = a
- (a XOR b) XOR a = b

### 2. 별 찍기 패턴 (b_star)

다양한 패턴으로 별을 출력하는 알고리즘을 학습했습니다.

#### 다이아몬드 패턴

```java
// 위쪽 삼각형
for (int i = 1; i <= input; i++) {
  // 공백 출력
  for (int j = 1; j <= input - i; j++) {
    System.out.print(" ");
  }
  // 별 출력
  for (int k = 1; k <= 2 * i - 1; k++) {
    System.out.print("*");
  }
  System.out.println();
}

// 아래쪽 삼각형
for (int i = input - 1; i >= 1; i--) {
  // 공백 출력
  for (int j = 1; j <= input - i; j++) {
    System.out.print(" ");
  }
  // 별 출력
  for (int k = 1; k <= 2 * i - 1; k++) {
    System.out.print("*");
  }
  System.out.println();
}
```

#### 나비 패턴

```java
// 윗부분 날개
for (int i = 1; i <= input; i++) {
  // 왼쪽 별
  for (int j = 1; j <= i; j++) {
    System.out.print("*");
  }
  // 가운데 공백
  for (int k = 1; k <= 2 * input - 2 * i; k++) {
    System.out.print(" ");
  }
  // 오른쪽 별
  for (int j = 1; j <= i; j++) {
    System.out.print("*");
  }
  System.out.println();
}

// 아랫부분 날개
for (int i = input - 1; i >= 1; i--) {
  // 왼쪽 별
  for (int j = 1; j <= i; j++) {
    System.out.print("*");
  }
  // 가운데 공백
  for (int k = 1; k <= 2 * input - 2 * i; k++) {
    System.out.print(" ");
  }
  // 오른쪽 별
  for (int j = 1; j <= i; j++) {
    System.out.print("*");
  }
  System.out.println();
}
```

### 3. 수학 알고리즘 (c_math)

#### 소수 판별

```java
// 기본 방식
private static boolean isPrime(int num) {
  if (num == 2) return true;
  if (num % 2 == 0) return false;

  for (int i = 3; i < num; i++) {
    if (num % i == 0) return false;
  }
  return true;
}

// 최적화 방식 (제곱근까지만 확인)
private static boolean isPrime2(int num) {
  if (num == 2) return true;
  if (num % 2 == 0) return false;

  for (int i = 3; i <= Math.sqrt(num); i++) {
    if (num % i == 0) return false;
  }
  return true;
}
```

#### 최대공약수 (GCD)

```java
// 반복문 방식
private static int getGcd(int a, int b) {
  int min = Math.min(a, b);

  for (int i = min; i > 0; i--) {
    if (a % i == 0 && b % i == 0) {
      return i;
    }
  }
  return 1;
}

// 유클리드 호제법
private static int getGcd2(int a, int b) {
  while (b > 0) {
    int temp = b;
    b = a % b;
    a = temp;
  }
  return a;
}
```

#### 최소공배수 (LCM)

```java
private static int getLcm(int a, int b) {
  int gcd = getGcd(a, b);
  return a * b / gcd;
}
```

#### 팩토리얼

```java
// 일반 재귀
private static int getFactorial(int i) {
  if (i < 0) {
    throw new IllegalArgumentException("음수 펙토리얼은 존재하지 않습니다.");
  } else if (i <= 1) {
    return 1;
  }
  return i * getFactorial(i - 1);
}

// 꼬리 재귀
private static int factorialTail(int i, int res) {
  if (i < 0) {
    throw new IllegalArgumentException("음수 팩토리얼은 존재하지 않습니다.");
  }
  if (i <= 1) {
    return res;
  }

  res = i * res;
  return factorialTail(--i, res);
}
```

### 4. 자료구조 (d_datastructure)

#### ArrayList 구현과 동작 원리

ArrayList는 동적 배열을 기반으로 한 자료구조로, 크기가 가변적이며 요소의 추가, 삭제, 조회가 가능합니다. 자바의 기본 ArrayList 클래스를 직접 구현해보며 내부 동작 원리를 학습했습니다.

##### 클래스 구조 및 필드 설명

```java
public class _ArrayList<E> {
  // 실제 데이터를 저장하는 배열
  private Object[] elementData;

  // 현재 저장된 요소의 개수
  private int size;

  // 내부 배열의 크기 (기본값 10)
  private int arraySize = 10;

  // 기본 생성자 - 초기 용량 10의 빈 배열 생성
  public _ArrayList() {
    elementData = new Object[arraySize];
  }

  // 초기 용량을 지정하는 생성자
  public _ArrayList(int initialCapacity) {
    this.arraySize = initialCapacity;
    elementData = new Object[arraySize];
  }
}
```

##### 기본 메서드 구현

1. **크기 및 상태 확인 메서드**

```java
// 현재 저장된 요소의 개수 반환
public int size() {
  return size;
}

// 비어있는지 확인
public boolean isEmpty() {
  return size == 0;
}
```

2. **요소 추가 메서드**

```java
public boolean add(E e) {
  // 현재 배열에 여유 공간이 있는 경우
  if (size < arraySize) {
    elementData[size] = e;
    size++;
    return true;
  }

  // 배열이 가득 찬 경우, 크기를 2배로 확장
  arraySize *= 2;
  elementData = Arrays.copyOf(elementData, arraySize);
  elementData[size] = e;
  size++;

  return true;
}
```

**동적 크기 조정의 원리:**

- 배열이 가득 차면 현재 크기의 2배로 새 배열을 생성
- `Arrays.copyOf()`를 사용하여 기존 데이터를 새 배열로 복사
- 이러한 방식으로 필요에 따라 배열 크기가 자동으로 증가

3. **요소 조회 메서드**

```java
@SuppressWarnings("unchecked")
public E get(int index) {
  // 인덱스 범위 검사
  if (index < 0 || index >= size) {
    throw new IndexOutOfBoundsException("인덱스 범위를 벗어났습니다.");
  }

  // Object 배열에서 요소를 가져와 제네릭 타입으로 캐스팅하여 반환
  return (E) elementData[index];
}
```

4. **요소 수정 메서드**

```java
@SuppressWarnings("unchecked")
public E set(int index, E element) {
  // 인덱스 범위 검사
  if (index < 0 || index >= size) {
    throw new IndexOutOfBoundsException("인덱스 범위를 벗어났습니다.");
  }

  // 기존 요소를 저장
  E prevElement = (E) elementData[index];

  // 새 요소로 교체
  elementData[index] = element;

  // 기존 요소 반환
  return prevElement;
}
```

5. **요소 삭제 메서드**

```java
@SuppressWarnings("unchecked")
public E remove(int index) {
  // 인덱스 범위 검사
  if (index < 0 || index >= size) {
    throw new IndexOutOfBoundsException("인덱스 범위를 벗어났습니다.");
  }

  // 삭제할 요소 저장
  E prevElement = (E) elementData[index];

  // 삭제 후 요소 이동 (시프트 연산)
  for (int i = index; i < size - 1; i++) {
    elementData[i] = elementData[i + 1];
  }

  // 마지막 요소 null 처리 (메모리 누수 방지)
  elementData[size - 1] = null;
  size--;

  // 삭제된 요소 반환
  return prevElement;
}
```

**삭제 연산의 원리:**

- 삭제된 위치 이후의 모든 요소를 한 칸씩 앞으로 이동 (시프트 연산)
- 배열 크기는 변경하지 않고 논리적 크기(size)만 감소
- 마지막 요소는 null로 설정하여 메모리 누수 방지

6. **문자열 표현 메서드**

```java
@Override
public String toString() {
  return "_ArrayList{" +
      "elementData=" + Arrays.toString(elementData) +
      '}';
}
```

#### ArrayList 성능 특성

1. **시간 복잡도**
   - 조회(get): O(1) - 인덱스로 직접 접근
   - 추가(add): 일반적으로 O(1), 배열 확장 시 O(n)
   - 삽입/삭제: O(n) - 요소 이동이 필요함
2. **공간 복잡도**

   - O(n) - n은 저장된 요소의 수
   - 내부 배열은 실제 요소 수보다 클 수 있음 (여유 공간)

3. **장단점**
   - 장점: 인덱스로 빠른 접근, 순차적 데이터 저장에 효율적
   - 단점: 중간 삽입/삭제가 비효율적, 크기 조정 시 오버헤드 발생

#### 테스트 코드 분석

```java
public static void main(String[] args) {
  System.out.println(init());  // ArrayList 초기화 및 출력
  testGet();                   // get 메서드 테스트
  testRemove();                // remove 메서드 테스트
  testForEach();               // forEach 메서드 테스트 (미구현)
}

// 테스트용 ArrayList 초기화
private static _ArrayList<Integer> init() {
  _ArrayList<Integer> list = new _ArrayList<Integer>();
  for (int i = 0; i < 15; i++) {
    list.add(i);  // 0부터 14까지 요소 추가
  }
  return list;
}

// get 메서드 테스트
private static void testGet() {
  _ArrayList<Integer> list = init();
  for (int i = 5; i < 8; i++) {
    System.out.println(list.get(i));  // 인덱스 5, 6, 7의 요소 출력
  }
}

// remove 메서드 테스트
private static void testRemove() {
  _ArrayList<Integer> list = init();

  for (int i = 5; i < 8; i++) {
    list.remove(i);  // 인덱스 5, 6, 7 요소 삭제
  }
  System.out.println(list);  // 삭제 후 리스트 출력
}
```

#### 구현 시 고려사항

1. **제네릭 사용**

   - 타입 안정성 보장
   - 컴파일 시점에 타입 검사
   - 런타임에 타입 캐스팅 오류 방지

2. **동적 크기 조정**

   - 요소 추가 시 배열 크기 자동 확장
   - 일반적으로 현재 크기의 2배로 확장 (성능과 메모리 사용의 균형)

3. **예외 처리**

   - 인덱스 범위 검사로 `IndexOutOfBoundsException` 발생
   - 잘못된 접근으로부터 데이터 보호

4. **메모리 관리**
   - 삭제된 요소는 null로 설정하여 메모리 누수 방지
   - 참조가 불필요해진 객체를 명시적으로 해제
