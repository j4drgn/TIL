# 2025-08-27 (수) 학습 내용

## 디자인 패턴 학습

오늘은 디자인 패턴 중 빌더 패턴(Builder Pattern)과 팩토리 패턴(Factory Pattern)에 대해 학습하고, 게임 구현 예제를 통해 전략 패턴(Strategy Pattern)의 활용을 심화 학습했습니다.

### 1. 빌더 패턴 (Builder Pattern)

빌더 패턴은 복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 생성할 수 있게 해주는 생성 패턴입니다.

#### 주요 코드 분석

```java
public class Book {
    // 불변(immutable) 객체를 위한 private 필드들
    private String title;
    private String author;
    private int page;
    private int price;

    // 생성자는 private으로 선언하여 외부에서 직접 생성 불가능
    // 오직 Builder를 통해서만 객체 생성 가능
    private Book(Builder builder) {
        title = builder.title;
        author = builder.author;
        page = builder.page;
        price = builder.price;
    }

    // 내부 정적 클래스로 Builder 구현
    public static class Builder {
        // Builder 클래스는 Book과 동일한 필드를 가짐
        private String title;
        private String author;
        private int page;
        private int price;

        // 메서드 체이닝을 위해 this 반환
        public Builder title(String title) {
            this.title = title;
            return this;
        }

        public Builder author(String author) {
            this.author = author;
            return this;
        }

        public Builder page(int page) {
            this.page = page;
            return this;
        }

        public Builder price(int price) {
            this.price = price;
            return this;
        }

        // 최종적으로 Book 객체 생성 및 반환
        public Book build() {
            return new Book(this);
        }
    }
}
```

#### 빌더 패턴 사용 예시

```java
public class Run {
    public static void main(String[] args) {
        // 빌더 패턴을 사용한 객체 생성
        // 1. 가독성이 좋음 - 어떤 값을 설정하는지 명확히 알 수 있음
        // 2. 유연성 - 필요한 값만 선택적으로 설정 가능
        // 3. 불변성 - 한번 생성된 객체는 변경 불가능
        Book book = new Book.Builder()
                .title("해리포터")
                .author("포터해리")
                .price(90000)
                .page(300)
                .build();
        System.out.println(book);
    }
}
```

#### 빌더 패턴의 장점

1. **가독성 향상**: 매개변수가 많은 생성자보다 어떤 값이 어디에 설정되는지 명확하게 알 수 있습니다.
2. **유연한 객체 생성**: 필요한 값만 선택적으로 설정할 수 있습니다.
3. **불변 객체 생성**: 객체 생성 후 상태를 변경할 수 없는 불변 객체를 만들 수 있습니다.
4. **매개변수 검증**: 빌더 메서드에서 유효성 검사를 수행할 수 있습니다.

#### 다른 객체 생성 패턴과의 비교

1. **자바빈 패턴**: 기본 생성자로 객체를 생성한 후 setter로 값을 설정하는 방식

   - 장점: 가독성이 좋음
   - 단점: 객체 생성 과정이 여러 단계로 분리되어 일관성이 없을 수 있고, 불변 객체를 만들 수 없음

2. **점층적 생성자 패턴**: 여러 개의 오버로딩된 생성자를 제공하는 방식
   - 장점: 불변 객체를 만들 수 있음
   - 단점: 매개변수가 많아지면 가독성이 떨어지고 관리가 어려움

### 2. 팩토리 패턴 (Factory Pattern)

팩토리 패턴은 객체 생성 로직을 캡슐화하여 클라이언트 코드와 분리하는 생성 패턴입니다. 객체 생성의 유연성을 높이고 코드 결합도를 낮추는 데 도움이 됩니다.

#### 주요 코드 분석

```java
// 인터페이스: 모든 메일 커넥터가 구현해야 하는 인터페이스
public interface SMTPConnector {
    void connect();
}

// 구현 클래스: 각 메일 서비스별 구체적인 구현
public class GoogleMail implements SMTPConnector {
    private EmailConfig config;

    public GoogleMail(EmailConfig config) {
        super();
        this.config = config;
    }

    @Override
    public void connect() {
        System.out.println(config.url);
        System.out.println("구글 메일서버에 연결되었습니다.");
    }
}

// 설정 정보를 담은 Enum 클래스
public enum EmailConfig {
    // 각 메일 서비스별 설정 정보 정의
    NAVER("smtp.naver.com", "mc", "123abc", 5000),
    DAUM("smtp.daum.com", "mc", "123abc", 5000),
    GOOGLE("smtp.google.com", "mc", "123abc", 5000);

    public final String url;
    public final String id;
    public final String password;
    public final int timeout;

    private EmailConfig(String url, String id, String password, int timeout) {
        this.url = url;
        this.id = id;
        this.password = password;
        this.timeout = timeout;
    }
}

// 팩토리 클래스: 객체 생성 로직을 캡슐화
public class ConnectorFactory {
    // 정적 팩토리 메서드: 설정에 따라 적절한 커넥터 객체 생성
    public static SMTPConnector create(EmailConfig config) {
        switch (config) {
        case DAUM: {
            return new DaumMail(config);
        }
        case NAVER: {
            return new NaverMail(config);
        }
        case GOOGLE: {
            return new GoogleMail(config);
        }
        default:
            throw new IllegalArgumentException("Unexpected value: " + config);
        }
    }
}
```

#### 팩토리 패턴 사용 예시

```java
public class Run {
    public static void main(String[] args) {
        // 팩토리 패턴을 사용한 객체 생성
        // 클라이언트는 구체적인 구현 클래스를 알 필요 없이
        // 인터페이스와 팩토리만 사용하여 원하는 객체를 생성
        SMTPConnector connector = ConnectorFactory.create(EmailConfig.GOOGLE);
        connector.connect();
    }
}
```

#### 팩토리 패턴의 장점

1. **결합도 감소**: 객체 생성 코드와 사용 코드의 결합도를 낮춥니다.
2. **캡슐화**: 객체 생성 로직을 캡슐화하여 클라이언트 코드를 간결하게 유지합니다.
3. **유지보수성**: 새로운 제품 클래스 추가 시 팩토리 클래스만 수정하면 됩니다.
4. **일관된 객체 생성**: 객체 생성 과정에서 일관된 방식으로 전처리/후처리를 적용할 수 있습니다.

#### 팩토리 패턴의 종류

1. **단순 팩토리(Simple Factory)**: 위 예제와 같이 하나의 팩토리 클래스가 모든 객체 생성을 담당
2. **팩토리 메서드(Factory Method)**: 객체 생성을 서브클래스에 위임하는 방식
3. **추상 팩토리(Abstract Factory)**: 관련된 객체들의 집합을 생성하는 인터페이스를 제공하는 방식

### 3. 게임 구현을 통한 전략 패턴 활용 (e_game)

텍스트 기반 로그라이크 게임 구현을 통해 전략 패턴(Strategy Pattern)의 실제 활용 사례를 학습했습니다.

#### 주요 구성 요소

1. **캐릭터 시스템**

   - Character 추상 클래스: 모든 캐릭터의 기본 속성과 메서드 정의
   - Player 클래스: 플레이어 캐릭터 구현, 장비 시스템과 연동
   - Monster 클래스: 몬스터 캐릭터 구현, 랜덤 공격력 계산

2. **아이템 시스템**

   - DamageWeight 인터페이스: 전략 패턴의 핵심, 공격/방어 가중치 계산 전략 정의
   - Equipment 클래스: 장비 아이템 구현
   - Equipments 클래스: 1급 컬렉션으로 장비 관리
   - Slot 열거형: 장비 슬롯 정의
   - EquipmentData 열거형: 게임 내 모든 장비 데이터 정의

3. **이벤트 시스템**

   - Event 인터페이스: 게임 내 이벤트 정의
   - TreasureEvent, HealEvent, MonsterEvent 클래스: 다양한 이벤트 구현
   - EventManager 클래스: 이벤트 관리 시스템

4. **게임 진행 시스템**
   - GameManager 클래스: 게임 전체 진행 관리
   - Run 클래스: 게임 실행 클래스

#### 전략 패턴 활용 사례

게임에서는 DamageWeight 인터페이스를 통해 전략 패턴을 구현했습니다. 각 장비는 서로 다른 공격/방어 전략을 가지며, 실행 시점에 장착된 장비에 따라 다른 전략이 적용됩니다.

```java
// 전략 인터페이스 (예시 코드)
public interface DamageWeight {
    int getAttackWeight(int baseAttack);
    int getDefenseWeight(int baseDefense);
}

// 구체적인 전략 구현 (예시 코드)
public class Equipment implements DamageWeight {
    private String name;
    private int attack;
    private int defense;
    private Slot slot;

    @Override
    public int getAttackWeight(int baseAttack) {
        return baseAttack + this.attack;
    }

    @Override
    public int getDefenseWeight(int baseDefense) {
        return baseDefense + this.defense;
    }
}
```

#### 게임 규칙

1. 용사는 8일 동안 모험을 떠납니다.
2. 하루에 하나의 이벤트가 무작위로 발생합니다.
3. 모든 이벤트를 완료하면 모험이 성공으로 종료됩니다.
4. 용사의 HP가 0이 되면 모험이 실패로 종료됩니다.

## 디자인 패턴 학습 요약

오늘 학습한 디자인 패턴들은 객체지향 프로그래밍의 핵심 원칙을 실현하는 방법을 제공합니다:

1. **빌더 패턴**: 복잡한 객체 생성 과정을 단순화하고 가독성을 높이며, 불변 객체를 쉽게 생성할 수 있게 해줍니다.

2. **팩토리 패턴**: 객체 생성 로직을 캡슐화하여 코드 결합도를 낮추고, 객체 생성의 유연성을 높여줍니다.

3. **전략 패턴**: 알고리즘군을 정의하고 각각을 캡슐화하여 상호 교체 가능하게 만들어, 런타임에 알고리즘을 선택할 수 있게 해줍니다.

이러한 패턴들은 코드의 재사용성, 유지보수성, 확장성을 높이는 데 큰 도움이 됩니다. 특히 게임 개발과 같이 복잡한 시스템에서는 이러한 패턴들을 조합하여 유연하고 확장 가능한 아키텍처를 구축할 수 있습니다.
