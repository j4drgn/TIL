# 2025-08-28 (목) 학습 내용

## 디자인 패턴 학습 내용

오늘은 다음 세 가지 디자인 패턴에 대해 학습했습니다:

1. 템플릿 콜백 패턴(Template Callback Pattern)
2. 프록시 패턴(Proxy Pattern)
3. 어댑터 패턴(Adapter Pattern)

---

### 1. 템플릿 콜백 패턴(Template Callback Pattern)

템플릿 콜백 패턴은 템플릿 메소드 패턴과 유사하지만, 상속 대신 객체 합성을 사용합니다. 특정 작업의 일부를 콜백으로 분리하여 재사용성과 유연성을 높이는 패턴입니다.

#### 구성 요소
- **템플릿(Template)**: 작업의 골격을 정의하고 콜백을 호출하는 클래스
- **콜백(Callback)**: 템플릿에서 호출될 기능을 정의하는 인터페이스
- **콜백 구현체**: 콜백 인터페이스를 구현한 클래스

#### 예제 코드

```java
// 콜백 인터페이스
@FunctionalInterface
public interface Timer {
    void start();
}

// 템플릿 클래스
public class TimeChecker {
    public void checkTime(Timer target) {
        long start = System.currentTimeMillis();
        
        target.start();  // 콜백 메소드 호출
        
        long end = System.currentTimeMillis();
        System.out.printf("소요시간 : %s \n", end - start);
    }
}
```

#### 장점
1. 코드 재사용성 증가
2. 핵심 로직과 부가 기능의 분리
3. 상속 없이 기능 확장 가능
4. 함수형 인터페이스와 람다식 활용 가능

#### 활용 사례
- 성능 측정
- 트랜잭션 처리
- 리소스 관리(try-with-resources)
- 이벤트 처리

---

### 2. 프록시 패턴(Proxy Pattern)

프록시 패턴은 특정 객체에 대한 접근을 제어하는 대리자 객체를 제공하는 패턴입니다. 원본 객체와 동일한 인터페이스를 구현하면서 추가적인 기능을 제공합니다.

#### 구성 요소
- **Subject(주체)**: 원본 객체와 프록시가 구현하는 인터페이스
- **RealSubject(실제 주체)**: 실제 작업을 수행하는 객체
- **Proxy(프록시)**: 실제 주체에 대한 참조를 유지하면서 접근을 제어하고 부가 기능을 제공하는 객체

#### 예제 코드

```java
// Subject 인터페이스
public interface Developer {
    void develop();
}

// RealSubject 구현체들
public class Man implements Developer {
    public void develop() {
        System.out.println("채팅서비스를 만든다.");
    }
}

public class Woman implements Developer {
    public void develop() {
        System.out.println("추천서비스를 만든다.");
    }
}

public class Child implements Developer {
    public void develop() {
        System.out.println("스트리밍서비스를 만든다.");
    }
}

// Proxy 클래스
public class DeveloperProxy implements Developer {
    private Developer developer;
    
    public DeveloperProxy(Developer developer) {
        super();
        this.developer = developer;
    }

    @Override
    public void develop() {
        System.out.println("[system] 출근 카드를 찍는다.");
        
        try {
            // 핵심로직 위임
            developer.develop();
        } catch (Exception e) {
            System.out.println("앗 쉬는 날이었다.");
        } finally {
            System.out.println("집에 간다.");
        }
    }
}
```

#### 프록시 패턴의 종류
1. **가상 프록시(Virtual Proxy)**: 객체의 생성 비용이 높을 때 필요한 시점까지 생성을 지연
2. **보호 프록시(Protection Proxy)**: 접근 권한 제어
3. **원격 프록시(Remote Proxy)**: 원격 객체에 대한 로컬 대리자 역할
4. **로깅 프록시(Logging Proxy)**: 메소드 호출에 대한 로깅 추가

#### 장점
1. 원본 객체의 수정 없이 부가 기능 추가 가능
2. 클라이언트 코드 변경 없이 기능 확장
3. 보안, 로깅, 캐싱 등의 공통 관심사 처리
4. 원본 객체의 생성 및 초기화 지연 가능

#### 활용 사례
- Spring AOP
- 데이터베이스 연결 풀링
- 원격 객체 접근(RMI)
- 지연 로딩

---

### 3. 어댑터 패턴(Adapter Pattern)

어댑터 패턴은 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 중간에서 변환해주는 패턴입니다. 기존 코드를 수정하지 않고 새로운 인터페이스와 함께 작동할 수 있게 합니다.

#### 구성 요소
- **Target(타겟)**: 클라이언트가 사용하는 인터페이스
- **Adaptee(어댑티)**: 기존에 존재하는 인터페이스(변환이 필요한 인터페이스)
- **Adapter(어댑터)**: Target 인터페이스를 구현하고 Adaptee 객체를 감싸서 Target 인터페이스로 변환하는 클래스

#### 예제 코드

```java
// Target 인터페이스
public interface SocialLogin {
    UserProfile login(String token);
}

// Adaptee 클래스들
public class GoogleApi {
    public GoogleProfile getProfile(String token) {
        return new GoogleProfile("하명도", "aaa@bbb.com");
    }
}

public record GoogleProfile(String username, String email) {}

public class NaverApi {
    public NaverProfile getProfile(String token) {
        return new NaverProfile("하명도_naver", "aaa@naver.com");
    }
}

public record NaverProfile(String name, String mail) {}

// 공통 반환 타입
public record UserProfile(String username, String mail) {}

// Adapter 클래스들
public class GoogleAdaptor implements SocialLogin {
    private final GoogleApi api = new GoogleApi();
    
    @Override
    public UserProfile login(String token) {
        GoogleProfile profile = api.getProfile(token);
        return new UserProfile(profile.username(), profile.email());
    }
}

public class NaverAdaptor implements SocialLogin {
    private final NaverApi api = new NaverApi();
    
    @Override
    public UserProfile login(String token) {
        NaverProfile profile = api.getProfile(token);
        return new UserProfile(profile.name(), profile.mail());
    }
}

// 클라이언트 코드
public class AuthService {
    public void socialLogin(SocialLoginProvider provider, String token) {
        SocialLogin socialLogin = switch (provider) {
        case NAVER -> new NaverAdaptor();
        case GOOGLE -> new GoogleAdaptor();
        default -> throw new IllegalArgumentException("Unexpected value: " + provider);
        };
        
        UserProfile userProfile = socialLogin.login(token);
        System.out.println(userProfile.username() + " 로그인 로직 시작");
    }
}
```

#### 어댑터 패턴의 종류
1. **객체 어댑터(Object Adapter)**: 합성(composition)을 사용하여 어댑티를 어댑터 내부에 포함
2. **클래스 어댑터(Class Adapter)**: 다중 상속을 사용하여 타겟과 어댑티를 모두 상속(Java에서는 불가능)

#### 장점
1. 기존 코드 재사용 가능
2. 호환되지 않는 인터페이스 간의 작업 가능
3. 기존 클래스 수정 없이 새로운 인터페이스 적용
4. 클라이언트 코드 변경 최소화

#### 활용 사례
- 서로 다른 API 통합
- 레거시 시스템과 신규 시스템 연동
- 외부 라이브러리 통합
- 다양한 데이터 형식 변환

---

## 디자인 패턴 간의 비교

| 패턴 | 목적 | 구현 방식 | 주요 특징 |
|------|------|-----------|----------|
| 템플릿 콜백 | 알고리즘의 뼈대는 유지하면서 특정 단계를 외부에서 주입 | 인터페이스와 합성 | 상속 없이 기능 확장, 함수형 인터페이스 활용 |
| 프록시 | 객체에 대한 접근 제어 및 부가 기능 추가 | 동일 인터페이스 구현 | 원본 객체 수정 없이 기능 추가, 지연 초기화 |
| 어댑터 | 호환되지 않는 인터페이스 연결 | 인터페이스 변환 | 기존 코드 재사용, 다양한 시스템 통합 |

## 결론

오늘 학습한 세 가지 디자인 패턴은 모두 객체지향 설계의 핵심 원칙인 '개방-폐쇄 원칙(OCP)'을 따르고 있습니다. 기존 코드를 수정하지 않고 새로운 기능을 확장하거나 다른 시스템과 통합할 수 있는 방법을 제공합니다. 특히 이러한 패턴들은 실무에서 자주 사용되며, 유지보수성과 확장성이 높은 코드를 작성하는 데 큰 도움이 됩니다.
