# 2025-08-22 (금)

## 알고리즘 학습 내용 정리

오늘은 알고리즘 폴더에 새롭게 추가된 코드들을 분석하고 학습했습니다. 주요 내용은 다음과 같습니다.

### 목차
1. [탐색 알고리즘](#탐색-알고리즘)
   - [선형 탐색(Linear Search)](#선형-탐색linear-search)
   - [이진 탐색(Binary Search)](#이진-탐색binary-search)
2. [정렬 알고리즘](#정렬-알고리즘)
   - [버블 정렬(Bubble Sort)](#버블-정렬bubble-sort)
   - [선택 정렬(Selection Sort)](#선택-정렬selection-sort)
3. [람다 표현식](#람다-표현식)
   - [함수형 인터페이스](#함수형-인터페이스)
4. [이진 탐색 트리(BST)](#이진-탐색-트리bst)
5. [유틸리티 클래스](#유틸리티-클래스)

---

## 탐색 알고리즘

### 선형 탐색(Linear Search)

선형 탐색은 배열의 처음부터 끝까지 순차적으로 탐색하는 가장 기본적인 탐색 알고리즘입니다.

```java
// 기본 선형 탐색 구현
private static int linearSearch(int[] nums, int target) {
    int i = 0;
    while(true) {
        if(i == nums.length) return -1; // 배열 끝까지 탐색했는데 찾지 못한 경우
        if(nums[i] == target) return i; // 원하는 값을 찾은 경우 해당 인덱스 반환
        i++;
    }
}
```

또한, 보초법(Sentinel Search)을 이용한 최적화된 선형 탐색도 구현되어 있습니다:

```java
// 보초법을 이용한 선형 탐색 최적화
private static int sentinelSearch(int[] nums, int target) {
    int lastIndex = nums.length - 1;
    if(nums[lastIndex] == target) return lastIndex; // 마지막 원소가 타겟인 경우
    
    nums[lastIndex] = target; // 마지막 위치에 타겟 값을 넣어 보초로 사용
    int i = 0;
    while(true) {
        if(target == nums[i]) {
            return i < lastIndex ? i : -1; // 찾은 위치가 원래 배열 범위 내인지 확인
        }
        i++;
    }
}
```

보초법은 매 반복마다 배열 범위 체크를 하지 않아도 되므로 성능이 약간 개선됩니다.

### 이진 탐색(Binary Search)

이진 탐색은 **정렬된 배열**에서만 사용할 수 있는 효율적인 탐색 알고리즘입니다. 중간값을 기준으로 탐색 범위를 절반씩 줄여나갑니다.

```java
private static int binarySearch(int[] nums, int target) {
    int lp = 0; // 왼쪽 포인터
    int rp = nums.length - 1; // 오른쪽 포인터
    
    while(lp <= rp) {
        int center = (lp + rp)/2; // 중간 위치 계산
        
        if(nums[center] == target) return center; // 찾은 경우
        
        if(target < nums[center]) {
            rp = center - 1; // 타겟이 중간값보다 작으면 왼쪽 부분 탐색
        } else {
            lp = center + 1; // 타겟이 중간값보다 크면 오른쪽 부분 탐색
        }
    }
            
    return 0; // 찾지 못한 경우 (실제로는 -1을 반환하는 것이 관례)
}
```

이진 탐색의 시간 복잡도는 O(log n)으로, 선형 탐색의 O(n)보다 훨씬 효율적입니다.

---

## 정렬 알고리즘

### 버블 정렬(Bubble Sort)

버블 정렬은 인접한 두 원소를 비교하여 정렬하는 간단한 알고리즘입니다.

```java
private static void bubbleSort(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr.length - 1; j++) {
            if(arr[j] > arr[j+1]) {
                SortUtil.swap(arr, j, j+1); // 인접한 두 원소 교환
            }
        }
    }
}
```

최적화된 버블 정렬 구현도 있습니다:

```java
private static void bubbleSort2(int[] arr) {
    for (int i = 1; i <= arr.length; i++) {
        boolean notSwap = true; // 교환이 발생하지 않았는지 체크
        for (int j = 0; j < arr.length - i; j++) {
            if(arr[j] > arr[j+1]) {
                SortUtil.swap(arr, j, j+1);
                notSwap = false; // 교환 발생
            }
        }
        
        if(notSwap) break; // 교환이 없었다면 이미 정렬된 상태이므로 종료
    }
}
```

이 최적화된 버전은 이미 정렬된 배열에 대해 O(n) 시간 복잡도를 가집니다.

### 선택 정렬(Selection Sort)

선택 정렬은 배열에서 최소값을 찾아 맨 앞으로 이동시키는 과정을 반복하는 알고리즘입니다.

```java
private static void selectionSort(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        int minIndex = indexOfmin(arr, i); // i부터 배열 끝까지 중 최소값의 인덱스 찾기
        SortUtil.swap(arr, i, minIndex); // 현재 위치와 최소값 위치 교환
    }
}

private static int indexOfmin(int[] arr, int pointer) {
    int min = pointer; // 최소값 인덱스 초기화
    for (int i = pointer + 1; i < arr.length; i++) {
        if (arr[min] > arr[i]) {
            min = i; // 더 작은 값 발견 시 인덱스 갱신
        }
    }
    return min;
}
```

선택 정렬의 시간 복잡도는 항상 O(n²)입니다.

---

## 람다 표현식

Java 8부터 도입된 람다 표현식은 함수형 프로그래밍을 지원하기 위한 기능입니다.

```java
/*
 * 람다 표현식 작성 규칙:
 * l. 매개변수의 타입은 생략한다
 * 2. 매개변수가 하나라면 매개변수 선언부의 괄호는 생략한다
 * 3. 코드블록에 코드가 한 줄이라면 {} 를 생략한다
 * 4. return 문만 존재하는 함수라면 {} 과 return 예약어를 생략한다.
 */
```

### 함수형 인터페이스

람다 표현식을 사용하기 위해 다음과 같은 함수형 인터페이스들이 구현되어 있습니다:

1. **Consumer<T>**: 값을 받아서 소비하고 반환값이 없는 인터페이스
```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```

2. **Supplier<T>**: 값을 제공하는 인터페이스
```java
@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

3. **Function<T, R>**: 값을 받아서 다른 값으로 변환하는 인터페이스
```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T arg, T arg2);
}
```

4. **Predicate<T>**: 값을 받아서 boolean을 반환하는 인터페이스
```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```

람다 표현식 사용 예:
```java
// 기본 람다 표현식
testConsumer(username -> System.out.println(username + "님! 환영합니다."));

// 여러 줄의 코드를 포함하는 람다
testConsumer(username -> {
    System.out.println("==========================");
    System.out.println(username + "님! 환영합니다.");
    System.out.println("==========================");
});

// 메서드 참조 사용
testConsumer(System.out::println);
```

---

## 이진 탐색 트리(BST)

이진 탐색 트리는 효율적인 탐색, 삽입, 삭제를 지원하는 트리 구조입니다.

주요 구현 내용:

1. **노드 클래스**:
```java
public class Node<E> {
    private E data;
    private Node<E> left;
    private Node<E> right;
    
    // 생성자 및 getter/setter 메서드들...
}
```

2. **삽입 연산**:
```java
public void insert(E element) {
    Node<E> newNode = new Node<>(element);
    
    if(size == 0) {
        root = newNode; // 트리가 비어있는 경우
        size++;
        return;
    }
    
    Node<E> link = root;
    
    while(true) {
        if(element.compareTo(link.data()) < 0) { // 왼쪽 서브트리로 이동
            if(link.left() == null) {
                link.left(newNode);
                break;
            }
            
            link = link.left();
        } else { // 오른쪽 서브트리로 이동
            if(link.right() == null) {
                link.right(newNode);
                break;
            }
            
            link = link.right();
        }
    }
    
    size++;
}
```

3. **삭제 연산**: 
   - 리프 노드 삭제
   - 자식이 하나인 노드 삭제
   - 자식이 둘인 노드 삭제 (후계자 노드 사용)

4. **트리 순회**:
   - 너비 우선 탐색(BFS)
   - 전위 순회(Preorder)
   - 중위 순회(Inorder)
   - 후위 순회(Postorder)

---

## 유틸리티 클래스

알고리즘 구현을 위한 유틸리티 클래스들이 구현되어 있습니다.

1. **SortUtil**: 정렬 알고리즘에 필요한 유틸리티 메서드 제공
```java
public static int[] createRandamIntArray(int size) {
    // 랜덤 정수 배열 생성
}

public static void swap(int[] arr, int i, int j) {
    // 배열의 두 요소 교환
}

public static void checkTime(Timer timer) {
    // 알고리즘 실행 시간 측정
}
```

2. **Timer**: 함수형 인터페이스로 시간 측정에 사용
```java
@FunctionalInterface
public interface Timer {
    void start();
}
```

이 유틸리티 클래스들은 정렬 및 기타 알고리즘의 성능 측정과 테스트에 유용하게 사용됩니다.
